线程间通讯
可以使用多个线程使用同一个对象，然后一个线程改变对象的属性，另一个线程也能感知，这种方法虽然可以实现通讯，但是有一个弊端，那就是线程需要不停的轮询对象，判断属性是否改变了，如果轮询的时间很短，那么会非常消耗cpu(死循环轮询),如果很长，那么拿到的值不一定是对的（不实时），见demo1

使用wait/notify/notifyAll机制
wait是Object的方法，在调用wait前，线程必须获得对象级锁，在wait后，释放锁，wait后，会重新进入就绪队列，继续竞争对象锁，如果线程在调用wait时，没有找到相应的锁，会抛出异常。
notify也是需要获得对象锁,如果有多个线程在wait，则线程规划器会随机选取一个线程，在调用notify后，wait线程并不会马上获得锁，需要notify执行完同步块代码并退出同步块后，才能获取，同理，调用notify并不能马上释放锁，执行完同步块代码才回释放，获得对象锁的wait线程在执行完同步块方法后，如果再次调用notify，那么即使现象锁是空闲的，但是其他的wait线程也不会被激活，还会继续阻塞等待，知道一个对象发出notify或notifyAll,总而言之，wait使线程停止运行，而notify使线程继续运行